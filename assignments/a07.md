

# Assignment 7

In this assignment you are going to be making a web version of the game **[2048](https://play2048.co/)**. We are going to lay out some of the requirements below, but you should play the game in order to get an understanding of how the mechanics work.

 The assignment will have an autograded portion as well as a portion that is graded by hand. The autograded part will be the game engine. This will be a fully functional version of the game that can even run in the console. We will be giving you the code to do the console part. The part that is not autograded is the web interface you make for playing the game. **In order for you to receive ANY credit for the web portion you must first receive a 100% on the autograded portion**.

> The reason we are splitting up the game engine from the web interface is to follow good design principles and keep our logic and data separate from the interface. In modern web development you will most likely be using a front end framework and be relying on a backend server for your data. With this configuration you will be simply laying out the structure you want your web pages to take on, and the data drives the rest. This makes it easy to develop because you never have to manage what happens when the data changes, the page simply reflects the data in real time. 

## 1. The Engine

When developing your engine, there are a few requirements you must meet, otherwise you have the freedom to implement it any way you seem fit. 

Below is the spec that your engine must follow or it will not be able to be graded.

### 1.1 The GameState Object

The `gameState` object will be used to load new games. It has uses for you in saving a users current session and this is also how the autograder will be able to effectively test your engine. 
```javascript
gameState = {
  board: number[], // array of numbers size^2 in length that represent the value of the tiles
  score: number, // score of the game at a given point in time
  won: boolean, // whether a user has combined to 1024 tiles to make a 2048
  over: boolean // has the user lost by running out of possible moves
}
```

Here is an example of a game and its corresponding `gameState`.
>Note that the board inside of `gameState` is a 1 dimensional array. You may implement your board with any memory structure you like, don't feel as though you need to use a 1d array. The only requirement imposed by us is that when you output a `gameState`, the board is a 1d array.


```javascript
 [ ] [ ] [2] [4]
 [ ] [2] [ ] [4]
 [ ] [ ] [4] [8]
 [2] [4] [8] [16]

{
  board: [
    0, 0, 2,  4, 0, 2,
    0, 4, 0,  0, 4, 8,
    2, 4, 8, 16
  ],
  score: 80,
  won: false,
  over: false
}
```



### 1.2 Game Class

The core of your **2048** implementation should be a class called `Game` inside a file called `game.js`. It should be directly inside the engine folder : `/a07/engine/game.js`.

#### Games should do the following:

- Have a constructor that takes a single argument `size` which is the width/height of the game. When `let game = new Game(4)` is called a new game of size 4x4 should be created. It should randomly add 2 tiles to the game.
- When new tiles are added to the game they should have a **90%** chance of being a **2** and a **10%** chance of being a **4**. They should be added to a random free spot in the grid. 
- When a move occurs randomly add a tile with the above probabilities.
- When no legal moves are available the game should end. 

#### Games should expose the following functions

`setupNewGame()`: resets the game back to a random starting position

`loadGame(gameState)`: given a `gameState` object, it loads that position, score, etc...

`move(direction)` : given 'up', 'down', 'left', or 'right' it makes the appropriate shifts and adds a random tile.

`toString()`: returns a string that is a text/ascii version of the game. *See the `gameState` section above for an example*.

`onMove(callback)`: Takes a callback, when a move is made, every callback should be called with the games current `gameState`

`onWin(callback)`: Takes a callback, when the game is won, every callback should be called with the games current `gameState`.

`onLose(callback)`: Takes a callback, when the game is lost, every callback should be called with the games current `gameState`.

`getGameState()`: returns a `gameState` object.
